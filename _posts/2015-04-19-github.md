---
layout: post
title: "github常用命令"
description: "no description"
category: Game
tags: [Game]
---
####git init

“git init”是我们新建git库时运行的第一条命令。那么这条命令都做了什么呢？

在当前目录创建“.git”文件夹，表示这个目录是一个git库。里面包括objects,，refs/heads，refs/tags等等文件，这些文件主要是记录一些和git库相关的映射信息，之后当你更新版本的时候，旧版本的内容也会保存在这个目录中，正是因为这个特性git才被称为分布式版本控制工具，每个本地库都包括所有版本。当然，为了减少空间消耗，采用了一些技术来压缩旧版本内容，比如相同的内容只存储一份。

如果当前目录已经是一个git库，那么这条命令不会覆盖已有的文件，只会重新进行初始化工作。所以这条命令是安全的。

####git add 

为什么是兄弟命令呢？因为这条命令最常用的情况就是在“git init”之后运行，下面我们看看这条命令到低做了什么：

使用当前工作树中的内容更新git的index。大家再看一遍这个命令“git add .”，最后一个“.”就代表当前目录。git的index是什么呢，大家可以理解为就是一个索引，里面包含的就是当前工作树（或者说当前库）中git管理的所有文件信息。
大家可能会想，我的文件有的修改过有的没修改过，git怎么处理呢？其实git的index中不仅会存储文件信息，还会存储文件状态，比如是否被修改等等。

还有一点要注意就是，这条命令可以多次运行，每次都会把当前工作树中的文件更新到index中。

形象地说，这条命令相当于告诉git：“检查一下这个目录中的文件是不是有变化，如果有那就记录下来。”

####git commit

前面我们介绍了使用“git init”来初始化库，“git add .”来将当前目录中的文件添加到git的管理中。下面我们就看看，怎么提交更改，也就是更新版本。

上文书说到，我们把当前目录中的文件交给git管理，具体的信息比如哪个文件是新增的哪个文件被修改了都记录在git的index中。但是需要注意的是，这还没有涉及到git的核心功能——版本控制。

如果我们仅仅是“git add .”，那么我们其实永远都处于同一个版本，因为我们一直在同一个index下工作。我们可以将index理解为一个缓存，commit命令就是将缓存写入硬盘并更新缓存，这样就会在硬盘中生成一个历史版本，可以让我们随时回退。

我们来看一个具体的例子吧：

git commit -m “my first version”

-m后面的字符串就是提交说明，必填。其实这个命令是将提交和添加说明合并起来了，日常使用中一般会使用这条命令，更加方便。

大家可以运行“git status”来查看一下，commit之前会看到我们从上一次commit到现在的所有改动，commit之后就什么信息都没有了。这也就意味着我们的改动已经全部“入库”了，现在已经是一个新开始了。

####git status

这条命令非常简单，就是列出当前库的所有文件状态，我们看一个典型的输出：

[root@localhost gender]# git status
 On branch master
 Your branch is ahead of 'origin/master'by 1 commit.

 Changed but not updated:
 (use "git add <file>..." to update what will becommitted)
  (use "git checkout -- <file>..." to discard changes inworking directory)

       modified:   server.c

no changes added to commit (use "gitadd" and/or "git commit -a")
可以看到当前的分支是master，有一个文件被修改但是没有更新。

如果要更新修改的话，运行“git add .”就可以了。

还记得我们上次说的index吗？这个东西相当于git的一个缓存，里面记录的就是当前库的所有文件状态。我们运行“git status”的时候，实际上git是把index里的内容和上一次commit的状态进行比较得出的不同。

简单来说，git status显示的就是从你上次更新版本之后产生的变更。

####git push

一般情况下我们运行的是“git push origin master”。

“origin”其实是库的源地址，那么什么是地址呢？其实地址就是网址，表示github服务器上的一个库。我们指定一个地址，就是告诉github：“这是我们要提交的目标地址”。

“origin”其实是一个代号，具体的地址配置在git的config当中。如果你喜欢的话可以随便给他起名，反正最终的目标地址是一样的。

那么源地址是什么意思呢？

我们可能大多数时候都是自己创建库自己提交，所以不用考虑太多。不过有的时候我们会clone别人的库，这个时候源地址就是人家库的地址了。

我们也可以自己添加地址，这样在push的时候就可以提交到不同的库中。具体的命令我们下次再讲。

那么什么是master呢？master就是要提交的目标分支。

分支很好理解，一个库可以有多个分支，每个分支之间是互相独立的。大型的工程一般都有多个分支，比如开发分支、稳定分支等等。

分支的意义就是将开发工作隔离成不同的部分，每个部分独立开发，然后等到了合适的时候再把分支合并。

好了，最后我们总结一下这个命令干了什么：把本地库提交到地址为origin的库中的master分支上。

####git clone

就像clone的意思一样，这条命令会把一个库从GitHub的服务器上克隆到你的电脑里。

一般来说我们会这样来使用这条命令"git clone xxx"，xxx就是我们想克隆的库的地址，可以在这个库的GitHub页面看到，如图： ![enter image description here][3]

这条命令会做三件事：

把整个库都下载到本地

根据库的信息为每一个分支生成对应的远程地址（之后push的时候会用到）

检出（checkout）当前分支，为之后的开发做好准备。
三件事做完之后，我们就可以开始在这个库上进行开发了。

####git log

我们都知道log是日志的意思，”git log”就是查看git的日志。来看一个典型的输出：

可以看到一共有三次commit以及每次commit的作者、时间和描述。

通过查看当前库的所有commit记录，我们可以知道谁在什么时间进行了commit。

这条命令还有很多可选参数，比如查询指定目录的log，显示更详细的信息等等，大家可以Google一下查看具体的参数。一般来说”git log”就够用了。

####git diff

diff是different的缩写，顾名思义，是用来找不同的。

“git diff”有非常多的参数，我们说说最常用的三种使用方法以及它们的区别：

“git diff”——不带任何参数运行，会显示当前工作目录中没有被添加的修改。

“git diff –cached”——显示当前工作目录中被添加但是没有被commit的修改。

“git diff HEAD”——显示当前工作目录中的所有修改。

需要注意两点：

这里的修改都是相对于上一个commit来说的。

红色的“添加”指的是”git add”命令，文件修改之后，如果不添加的话，是不会被Git管理的。

有点乱是吧，由于大家实际使用的时候一般是commit -a，这样会把所有的修改先添加再commit，所以一般来说只要使用”git diff HEAD”命令就可以了。

还有一个非常常用的用法——”git diff -stat”，这条命令会显示当前工作目录下所有被修改的文件以及改动的行数，非常实用。

最后和”git status”做个对比吧，这两条命令乍一看都是显示文件的变动，区别就是”git diff”显示的细节更多，而”git status”只会显示哪个文件被改动。

